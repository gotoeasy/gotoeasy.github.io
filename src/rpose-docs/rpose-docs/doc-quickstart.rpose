[view]
<div @class="box-sizing--border-box padding-0_20px_20px_20px">

    <doc-title>快速上手</doc-title>
    来一份源码，我来让他跑起来<br>
    怎么安装、如何配置等等，都是水到渠成的事<br>

    <doc-title>2.1 第一个 hello world 组件</doc-title>

```rpose
// 文件名 ui-helloworld.rpose

\[api]
statekeys = name   // 意思是说，组件的状态不是外部所能随便改的，这里声明仅接受‘name’的修改

\[view]
<span>hello {name}!</span>

\[state] // 状态默认值，如果没有接收到name参数，显示的就是world了，避免空白难看
{
    name: 'world'
}
```

这就是创建了一个组件了，功能上很简单，接受name参数然后拼接显示<br>
组件名根据文件名转换而来，即 UiHelloworld，也就是意味着文件名不能乱写特殊字符，这应该不算事<br>


<!---------------------------------------------------------------------------------------->
    <doc-title>2.2 使用 hello world 组件</doc-title>
    为了看到 hello world 的效果，简单写一个页面<br>
    页面也是组件，不过是多了个挂载显示
```rpose
// 文件名 demo-quickstart-d2.rpose

\[view]
<ui-helloworld/>

\[mount] // 挂载显示
body
```
这便是把 hello world 组件用起来了，效果用想，显示出“hello world!”而已，不信点这里 <a href="demo/demo-quickstart-d2.html" target="_blank"><svgicon src="link" fill="blue"/></a>




<!---------------------------------------------------------------------------------------->
    <doc-title>2.3 修改 hello world 组件状态</doc-title>
    要修改组件状态，3个要素，什么组件？什么时机？改成什么？<br>
    下面代码演示，在输入框onchange时，拿到hello world组件对象，把它的name修改为输入框的值
```rpose
// 文件名 demo-quickstart-d3.rpose

\[view]
<div>
    <input onchange="fnChange">
    <ui-helloworld @ref="hello" name="rpose" />
</div>

\[actions]
{
    fnChange: e=> {
        let txt = e.target.value;
        let helloworld = this.getRefComponent('hello');
        helloworld.setState({name:txt});
    }
}

\[mount] // 挂载显示
body
```

要点1，事件的绑定，沿用html习惯直接写onchange的，处理函数是写在[actions]里的，通过名称关联起来的<br>
要点2，取组件对象，设定@ref属性，组件对象默认提供getRefComponent方法可用<br>
要点3，修改状态，沿用习惯通过组件的setState方法实现<br>
<br>
看效果点这里 <a href="demo/demo-quickstart-d3.html" target="_blank"><svgicon src="link" fill="blue"/></a><br>
<br>
扩充点1，组件根部是一个标签节点，多了不行。为什么要这样，习惯...其实主要是影响虚拟节点比较的算法实现<br>
扩充点2，还有getRefComponents方法，返回的是数组，还有getRefElements、getRefElement方法，对应返回真实Dom<br>
扩充点3，还有getState方法，返回组件状态的副本<br>



<!---------------------------------------------------------------------------------------->
    <doc-title>2.4 使用样式</doc-title>
    三驾马车HTML/JS/CSS就剩下CSS了<br>
    没什么难的，rpose最讲究的是姿势，直接加就是
```rpose
// 文件名 demo-quickstart-d4.rpose

\[view]
<div>
    <input class="demo-input" onchange="fnChange">
    <ui-helloworld @ref="hello" name="rpose" />
</div>

\[css]
.demo-input{
    margin: 10px;
    background-color: gold;
}

// [actions]、[mount]的代码同上节，省略...

```

要点，就是不想要要点，就像html+css那样直白<br>
当然，为了习惯，写[scss]、[less]都是可以的，尝试吧<br>
<br>
看效果点这里 <a href="demo/demo-quickstart-d4.html" target="_blank"><svgicon src="link" fill="blue"/></a><br>
<br>
<br>
有顾虑？确实，样式问题还是很多的<br>
比如，常规的添加前缀、压缩去重复、url地址修改图片资源复制，等等，rpose会整合相关工具处理，打消顾虑<br>
<br>
样式类名冲突？<br>
这个rpose花了点力气，按组件单位，把样式类名哈希化，能确保无冲突<br>
所以也是有推荐写法的，就是尽量使用类名，尽量不用标签名或id，避免rpose无法帮忙

<!---------------------------------------------------------------------------------------->
    <doc-title>2.5 再来几个组件熟悉一下</doc-title>
    代码块语法高亮组件<br>
    免不了要展示代码，吸收md格式写法的便利性，再加上highlight.js的API，rpose就这样内置了一个组件<br>
```rpose
// 代码块语法高亮，例子1
\[view]
\```
var hello = name => 'Hello ' + name + '!';
\```
```
效果：
```
var hello = name => 'Hello ' + name + '!';
```

<br>
继续，效果就免了，仅小小区别
```
// 例子2，加上语言，和md一样
\```js
var hello = name => 'Hello ' + name + '!';
\```


// 例子3，代码很多行的时候，得限制最大高度
\```js max-height=50px  // 事实上写法比较随意，比如其实这样写也是一样的 ```js 50px
var hello = name => 'Hello ' + name + '!';

    ...
    ...
    ...

\```
```

<!---------------------------------------------------------------------------------------->
    <doc-title>2.6 简单的的分隔线组件</doc-title>
    就是首页上的那根线<br>
    这个组件概念上等同于无状态组件，因为没有声明statekeys的具体项，状态无法修改
```rpose  380px
// 文件名 ui-line.rpose

\[api]
optionkeys = height, width, color, margin

\[view]
<div style="background-color:{color};height:{height};min-height:{height};width:{width};margin:{margin}"></div>

\[options]
{
    height: '1px',
    width: '98%',
    color: '#e6e6e6',
    margin: '20px auto 20px auto',
}
 
// 用法，比如这样用：<ui-line/>，或是这样用：<ui-line height="3px" width="50%" color="#ff9408"/>
```

<!---------------------------------------------------------------------------------------->
    <doc-title>2.7 简单的按钮组件</doc-title>
    这个按钮组件能修改状态<br>
    通过statekeys声明看出，仅有value和disabled能改，也就是只能改按钮文字以及是否禁用
```rpose 380px
// 文件名 ui-button.rpose

\[api]
optionkeys = onclick
statekeys  = value, disabled

\[view] 此组件仅为演示用途，并非最佳实践
<button onclick={$options.onclick} class="ui-button" disabled={!!$state.disabled}>{$state.value}</button>

\[less]
.ui-button {
    min-width: @theme-button-min-width;
    height: @theme-button-height;
    border: 1px solid #999999;
    font-weight: bold;
    border-radius: 3px;
    color: #333333;
    background: @theme-button-bg;
}

.ui-button:hover:not([disabled]),
.ui-button:focus{
    background: @theme-button-bg-hover;
}

.ui-button:active:not([disabled]){
    background: @theme-button-bg-active;
}

.ui-button[disabled]{
    background: @theme-button-bg-disabled;
    opacity: 0.6;
    cursor: not-allowed;
}
```

出现了新要点，less样式里面用到了变量，比如@theme-button-min-width等，怎么来的？<br>
这关系到一个统一性思想，都各自写非常细化的独立组件，统一性又怎么解决？<br>
对于样式风格，抽象后本质上是统一使用变量，rpose把theme变量独立出来发布成npm包来用<br>
通过这种方式，解决样式风格统一性问题，也让风格的统一修改变得更直观更直接<br>
<br>
目前是点到即止，仅尝试几个变量，有机会再完善，但即使目前想要扩充也是很方便的<br>
具体例子看两个包： @gotoeasy/theme 和 rpose-theme-demo<br>
@gotoeasy/theme的目的是统一变量名，rpose-theme-demo则是个性化变量值，也可以添加个性变量<br>
本例的变量就是从rpose-theme-demo包中得来的

<!---------------------------------------------------------------------------------------->
    <doc-title>2.8 组装几个按钮到页面看效果</doc-title>
```rpose 380px
// 文件名 demo-quickstart-d8.rpose

\[view]
<div class="warp">
    <ul>
        <li>{$state.msg}</li>
        <li><ui-button onclick="btn1Click" value="按钮1"/></li>
        <li><ui-button onclick="btn2Click" value="按钮2"/></li>
        <li><ui-button onclick="btn3Click" @ref="btn3" value="模拟重试"/></li>
    </ul>
</div>

\[state]
{
  msg:'点击按钮看效果',
  cnt1:0,
  cnt2:0,
}

\[actions]
{
    btn1Click: e=>{
        this.$state.cnt1++;
        this.$state.msg = '点击按钮1，共 ' + this.$state.cnt1 + ' 次';
        this.render();
    },
    btn2Click: function(e){
        this.$state.cnt2++;
        this.$state.msg = '点击按钮2，共 ' + this.$state.cnt2 + ' 次';
        this.render();
    },
    btn3Click: function(e){

        let sec = 5;
        let btn3 = this.getRefComponent("btn3");
       
        btn3.setState({disabled:true, value: sec-- + '秒后重试'});
        let tid = setInterval(()=>{
            btn3.setState({disabled:true, value: sec-- + '秒后重试'});
            if (sec < 0 ){
                clearInterval(tid);
                btn3.setState({disabled:false, value:'模拟重试'});
            }
        }, 1000);
    },
}

\[css]
.warp li{
    margin: 20px;
}

\[mount]
body
```

看效果点这里 <a href="demo/demo-quickstart-d8.html" target="_blank"><svgicon src="link" fill="blue"/></a><br>
<br>
也是有要点的<br>
没有[api]声明可变属性，也就是不让外面修改，但内部自己当然是可以改state的，改完之后调用了组件的内置方法render重绘<br>
主要是那个[actions]里面有function啊，function用了this，但function却没有bind(this)！？<br>
<br>
确实，不管习惯上或事实上，都是让this指向组件对象，rpose也是这样，this一定是本组件对象<br>
既然如此，为什么还要写bind(this)呢？写bind(this)不过是再次强调，this就是本组件自己<br>
我不喜欢这种啰嗦的姿势，更怕万一漏写而导致出bug，所以rpose选择自动把function改成了箭头函数，放心的使用this吧<br>



<!---------------------------------------------------------------------------------------->
    <doc-title>小结</doc-title>
    通过本章节，对rpose的代码写法的熟悉程度，可以说已基本掌握了<br>
    写个伪html，写个样式，加上事件写些脚本，最基础的东西其实都已经有了<br>

    <br>
    [api]声明选项配置项、声明状态可变项，不是使用时能乱改的<br>
    [view]就像html，模板语法很大众，免试入门<br>
    [actions]写事件函数，一个个js方法，没有特别的技术要求<br>
    [css]或[less]或[scss]写样式，样式的众多顾虑问题，rpose都帮忙铲除，还提供了theme风格方案<br>
    组件，有那么些内置方法如getState、setState、getRefComponent、getRefElement、render等<br>
    <br>
    到目前为止，已经能应付大部分的功能实现，有兴趣就可以开始动手尝试了<br>

   
    <doc-footer>青松 2018.12</doc-footer>

</div>
