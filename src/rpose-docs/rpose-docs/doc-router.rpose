[view]
<div @class="box-sizing--border-box padding-0_20px_20px_20px">

    <doc-title>7.1 关于前端路由</doc-title>
    前端路由没有标准，都是按经验自由发挥，差异体现在不同的接口设计<br>
    各自造轮子的极端，一种是简陋，附上例子说几行代码就能搞定，讲原理的层次<br>
    另一种是过度设计，追求无限的灵活性，为了路由而路由，谈艺术的层次<br>

    <br>
    前端路由本质上是为了支持浏览器的前进后退操作，能模拟页面跳转但又不跳出当前SPA页<br>
    因此，rpose控制复杂度，注重易用性，不会一股脑的支持各种功能<br>
    <ul style="">
        <li>使用锚点hash模式，暂不支持history模式，因为history模式刷新时需要服务端配合，不科学</li>
        <li>不支持显式传参，比如#user/:id或#product?code=123，直接暴露业务数据，不安全。通过隐式参数或哈希化参数的方式解决</li>
        <li>不支持嵌套路由，每看到一个地址或嵌套组件，需要脑筋也同步嵌套配合，过于复杂化</li>
        <li>自动检查判断，支持historyApi则优先使用，否则使用hashchange方式实现前端路由</li>
        <li>提供路由组件，声明式组装，通配符式匹配</li>
        <li>提供路由链接组件，组件式传参，透明化内部细节</li>
        <li>提供路由事件，便于切换路由时组件自行按业务控制页面展示</li>
    </ul>

    <br>
    以下简要介绍用法

<!---------------------------------------------------------------------------------------->
    <doc-title>7.2 使用路由标签</doc-title>
    通常，页面用路由标签包裹起来，同时指定匹配的路径就行了
```rpose
\[view]
<div>
    <ul>
        <li><a href="#foo">foo</a></li>
        <li><a href="#bar">bar</a></li>
        <li><a href="#baz">baz</a></li>
    </ul>
    <router path="foo"><page-foo/></router>
    <router path="bar"><page-bar/></router>
    <router path="baz"><page-baz/></router>
</div>
```

    这个组件就是简单的把三个页面组件拼成一个SPA页面<br>
    其中router是个内置的标签组件，path属性指定匹配的路由地址<br>


<!---------------------------------------------------------------------------------------->
    <doc-title>7.3 设定初期默认页面</doc-title>
    初次加载SPA时，如果路由地址有误，但仍旧希望显示默认路由，加上default属性声明即可

```rpose
\[view]
<div>
    <ul>
        <li><a href="#foo">foo</a></li>
        <li><a href="#bar">bar</a></li>
        <li><a href="#baz">baz</a></li>
    </ul>
    <router path="foo" default><page-foo/></router> <!-- default -->
    <router path="bar"><page-bar/></router>
    <router path="baz"><page-baz/></router>
</div>
```

    这里的foo页有default声明，如果初期打开时指定了不存在的路由名，foo页将作为默认页被显示


<!---------------------------------------------------------------------------------------->
    <doc-title>7.4 设定notfound页面</doc-title>
    SPA加载显示后，切换路由时如果出现错误地址，通常是希望显示404页，这时可以通过notfound属性声明
```rpose
\[view]
<div>
    <ul>
        <li><a href="#foo">foo</a></li>
        <li><a href="#bar">bar</a></li>
        <li><a href="#baz">baz</a></li>
        <li><a href="#xyz">xyz</a></li>
    </ul>
    <router path="foo" default><page-foo/></router> <!-- default -->
    <router path="bar"><page-bar/></router>
    <router path="baz"><page-baz/></router>
    <router notfound>
        <div style="color:red;font-size:5rem;"><b>404</b></div>
    </router>
</div>
```

    打开后点击xyz，由于不存在xyz的路由，将显示notfound页，地址栏直接输入错误地址也会是同样效果<br>
    默认页和notfound页都是路由找不到时才显示，区别在于默认页仅适用于初期加载显示时机


<!---------------------------------------------------------------------------------------->
    <doc-title>7.5 通配符匹配路由</doc-title>
    路由支持使用通配符 * 进行匹配，星号表示任意字符
```rpose
\[view]
<div>
    <ul>
        <li><a href="#foo">foo</a></li>
        <li><a href="#bar">bar</a></li>
        <li><a href="#baz">baz</a></li>
    </ul>
    <router path="foo" default><page-foo/></router> <!-- default -->
    <router path="bar"><page-bar/></router>
    <router path="ba*"><page-baz/></router>
    <router notfound>
        <div style="color:red;font-size:5rem;"><b>404</b></div>
    </router>
</div>
```

    路由匹配顺序无关、数量无关，可以同时匹配多个，全部匹配的都会被显示
    本例点击bar链接时，同时匹配bar、baz这2个路由，将会一起显示



<!---------------------------------------------------------------------------------------->
    <doc-title>7.6 路由链接组件</doc-title>
    内置router-link组件，对a标签进行包装，简化使用<br>
```rpose
\[view]
<div>
    <ul">
        <li><router-link path="foo">foo</router-link></li>
        <li><router-link path="bar">bar</router-link></li>
        <li><router-link path="baz">baz</router-link></li>
    </ul>
    <router path="foo" default><page-foo/></router> <!-- default -->
    <router path="bar"><page-bar/></router>
    <router path="baz"><page-baz/></router>
</div>
```

    本例router-link组件接受path属性，代表链接，直接使用路由名就行<br>
    注：如果path属性以http:或https:或.开头，将被视为普通链接地址使用
    


<!---------------------------------------------------------------------------------------->
    <doc-title>7.7 参数传递</doc-title>
    参数传递，组件router-link按传参方式传入params属性即可，效果上在地址栏不会直接暴露数据<br>
```rpose
\[view]
<div>
    <ul>
        <li><router-link path="foo" params={{id:'id-001'}}>foo</router-link></li>
        <li><router-link path="bar">bar</router-link></li>
    </ul>
    <router path="foo"><div style="font-size:3rem;"><b>foo</b><br>id: {$state.id}</div></router>
    <router path="bar"><div style="font-size:3rem;"><b>bar</b></div></router>
</div>

\[state]
{id: ''}

\[methods]
{
    init: () => {
        rpose.on('router.onroute', ctx => {
            let path = ctx.path;        // 这是router-link标签中传递的path值
            let state = ctx.state;      // 这是router-link标签中传递的params值
            path == 'foo' && (this.$state.id = state.id) && this.render(true);   // 激活foo页时更新显示id
        });
    }
}
```

    对于不支持historyApi的浏览器环境，传参数时地址栏将自动使用哈希串避免数据安全问题，同时也能避免参数过长的错误发生<br>
    <br>
    本例出现事件router.onroute，在路由切换时将被触发<br>
    <br>
    另外，这里用到了[methods]块定义，和[actions]的区别是，[methods]中定义的方法会都会被转译为组件对象的方法<br>
    在[methods]中的init方法名是约定的初始方法，对象创建后就会被调用，所以可以用来安装相关事件<br>
    在[methods]中定义的方法如果和内置方法名重复，将会替代原内置方法，比如可以自定义render方法替代默认的render处理逻辑<br>
    <br>
    还有，用到了rpose的事件处理接口rpose.on<br>
    完整的事件接口有on：安装事件函数，off：卸载事件函数，once：安装执行一次就自动卸载的事件函数，at：触发执行事件



<!---------------------------------------------------------------------------------------->
    <doc-title>小结</doc-title>
    前端路由的技术原理虽然简单，但实现方式没有标准，自由发挥，rpose的定位是简便易用<br>
    提供路由组件、路由链接组件、路由事件，没有花哨功能，基本满足常见业务需求<br>
    优先使用historyApi实现hash模式路由，隐式传参避免数据安全问题<br>
    <br>
    附带扩充点<br>
    rpose事件接口： on、off、once、at<br>
    [methods]块定义组件方法的作用，及特殊的init方法的用途<br>

   
    <doc-footer>青松 2019.01</doc-footer>

</div>
